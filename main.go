package main

import (
	"flag"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	flagCorpusUtil = flag.Bool("corpus-util", false, "build a utility for converting between native Go corpus and libfuzzer corpus")

	flagFunc = flag.String("func", "Fuzz", "fuzzer entry point")
	flagO    = flag.String("o", "", "output file")
	flagPath = flag.String("abs_path", "", "absolute path to fuzzer")
	flagKeep = flag.Bool("keep", false, "do not delete the binary")

	flagRace = flag.Bool("race", false, "enable data race detection")
	flagTags = flag.String("tags", "", "a comma-separated list of build tags to consider satisfied during the build")
	flagV    = flag.Bool("v", false, "print the names of packages as they are compiled")
	flagWork = flag.Bool("work", false, "print the name of the temporary work directory and do not remove it when exiting")
	flagX    = flag.Bool("x", false, "print the commands")
)

func main() {
	flag.Parse()

	if !token.IsIdentifier(*flagFunc) || !token.IsExported(*flagFunc) {
		log.Fatal("-func must be an exported identifier")
	}

	tags := "gofuzz,gofuzz_libfuzzer,libfuzzer"
	if *flagTags != "" {
		tags += "," + *flagTags
	}

	buildFlags := []string{
		"-tags", tags,
		"-trimpath",
	}
	if !*flagCorpusUtil {
		buildFlags = append(buildFlags,
			"-buildmode", "c-archive",
			"-gcflags", "all=-d=libfuzzer",
		)
	}

	suppress := []string{
		"syscall", // https://github.com/google/oss-fuzz/issues/3639
	}
	for _, pkg := range suppress {
		buildFlags = append(buildFlags, "-gcflags", pkg+"=-d=libfuzzer=0")
	}

	if *flagRace {
		buildFlags = append(buildFlags, "-race")
	}
	if *flagV {
		buildFlags = append(buildFlags, "-v")
	}
	if *flagWork {
		buildFlags = append(buildFlags, "-work")
	}
	if *flagX {
		buildFlags = append(buildFlags, "-x")
	}

	if len(flag.Args()) != 1 {
		log.Fatal("must specify exactly one package path")
	}
	path := flag.Args()[0]
	if strings.Contains(path, "...") {
		log.Fatal("package path must not contain ... wildcards")
	}
	pkgs, err := packages.Load(&packages.Config{
		Mode:       packages.NeedName,
		BuildFlags: buildFlags,
	}, "pattern="+path)
	if err != nil {
		log.Fatal("failed to load packages:", err)
	}
	if packages.PrintErrors(pkgs) != 0 {
		os.Exit(1)
	}
	if len(pkgs) != 1 {
		log.Fatal("package path matched multiple packages")
	}
	pkg := pkgs[0]

	importPath := pkg.PkgPath
	if strings.HasPrefix(importPath, "_/") {
		importPath = path
	}

	mainFile, err := ioutil.TempFile(".", "main.*.go")
	if err != nil {
		log.Fatal("failed to create temporary file:", err)
	}
	cleanup := func() {
		if !*flagKeep {
			os.Remove(mainFile.Name())
		}
	}
	defer cleanup()

	type Data struct {
		PkgPath      string
		Func         string
		Declarations string
		FuzzerParams string
	}
	/*err = mainTmpl.Execute(os.Stdout, &Data{
		PkgPath: importPath,
		Func:    *flagFunc,
	})*/
	//return
	tmpl := mainTmpl
	if *flagCorpusUtil {
		tmpl = corpusUtilTmpl
	}
	err = tmpl.Execute(mainFile, &Data{
		PkgPath: importPath,
		Func:    *flagFunc,
	})
	if err != nil {
		cleanup()
		log.Fatal("failed to execute template:", err)
	}
	if err := mainFile.Close(); err != nil {
		cleanup()
		log.Fatal(err)
	}

	out := *flagO
	if out == "" {
		out = pkg.Name + "-fuzz.a"
	}

	args := []string{"build", "-o", out}
	args = append(args, buildFlags...)
	args = append(args, mainFile.Name())
	cmd := exec.Command("go", args...)
	//cmd := exec.Command("gotip", args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		cleanup()
		log.Fatal("failed to build packages:", err)
	}
}

var mainTmpl = template.Must(template.New("main").Parse(`
// Code generated by go-118-fuzz-build; DO NOT EDIT.

// +build ignore

package main

import (
	"unsafe"
	target {{printf "%q" .PkgPath}}
	"github.com/AdamKorcz/go-118-fuzz-build/utils"
)

// #include <stdint.h>
import "C"

//export LLVMFuzzerTestOneInput
func LLVMFuzzerTestOneInput(data *C.char, size C.size_t) C.int {
	s := unsafe.Slice((*byte)(unsafe.Pointer(data)), size)
	//target.{{.Func}}(s)
	ok := LibFuzzer{{.Func}}(s)
	if !ok {
		return -1
	}
	return 0
}

func LibFuzzer{{.Func}}(data []byte) bool {
	fuzzer := utils.NewF("LibFuzzer", data)
	target.{{.Func}}(fuzzer)
	return !fuzzer.Skipped()
}

func main() {
}
`))

var corpusUtilTmpl = template.Must(template.New("corpus-util").Parse(`
// Code generated by go-118-fuzz-build; DO NOT EDIT.

// +build ignore

package main

import (
	"os"
	"io"
	"log"
	"fmt"
	target {{printf "%q" .PkgPath}}
	"github.com/AdamKorcz/go-118-fuzz-build/utils"
)

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s [go2lib|lib2go]\n", os.Args[0])
		os.Exit(1)
	}

	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}

	var output []byte
	var ok bool
	switch os.Args[1] {
	case "go2lib":
		fmt.Fprintln(os.Stderr, "Sorry, this has not been implemented")
		os.Exit(1)
	case "lib2go":
		output, ok = utils.LibFuzzerToNative(target.{{.Func}}, input)
		if !ok {
			fmt.Fprintln(os.Stderr, "Corpus may be incomplete (not enough values)")
		}
	default:
		fmt.Fprintf(os.Stderr, "Usage: %s [go2lib|lib2go]\n", os.Args[0])
		os.Exit(1)
	}

	_, err = os.Stdout.Write(output)
	if err != nil {
		log.Fatal(err)
	}
}
`))
